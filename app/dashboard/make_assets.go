// +build ignore

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"runtime"
)

func main() {
	if err := mainerr(); err != nil {
		log.Fatal(err)
	}
}

// Command line flags.
var (
	output  = flag.String("output", "", "path to output file (default stdout)")
	pkg     = flag.String("pkg", "", "package name")
	varname = flag.String("var", "Assets", "variable name")
)

func mainerr() error {
	flag.Parse()

	filenames, err := Expand(flag.Args())
	if err != nil {
		return err
	}

	assets, err := LoadAssets(filenames)
	if err != nil {
		return err
	}

	cfg := &Config{
		PackageName: *pkg,
		Variable:    *varname,
	}

	b, err := Generate(cfg, assets)
	if err != nil {
		return err
	}

	if *output != "" {
		err = ioutil.WriteFile(*output, b, 0644)
	} else {
		_, err = os.Stdout.Write(b)
	}

	return err
}

// Expand provided arguments into a file list.
func Expand(patterns []string) ([]string, error) {
	paths, err := ExpandPatterns(patterns)
	if err != nil {
		return nil, err
	}
	return ExpandDirectories(paths)
}

// ExpandPatterns expands glob patterns into a full list of files.
func ExpandPatterns(patterns []string) ([]string, error) {
	filenames := []string{}
	for _, pattern := range patterns {
		matches, err := filepath.Glob(pattern)
		if err != nil {
			return nil, err
		}
		filenames = append(filenames, matches...)
	}
	return filenames, nil
}

// ExpandDirectories expands any directories in the paths list to all the files
// under that path.
func ExpandDirectories(paths []string) ([]string, error) {
	var filenames []string
	for _, path := range paths {
		files, err := ExpandDirectory(path)
		if err != nil {
			return nil, err
		}
		filenames = append(filenames, files...)
	}
	return filenames, nil
}

// ExpandDirectory returns all files under the given path.
func ExpandDirectory(path string) ([]string, error) {
	info, err := os.Stat(path)
	if err != nil {
		return nil, err
	}
	if !info.IsDir() {
		return []string{path}, nil
	}
	var filenames []string
	err = filepath.Walk(path, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if !info.IsDir() {
			filenames = append(filenames, path)
		}
		return nil
	})
	if err != nil {
		return nil, err
	}
	return filenames, nil
}

type Asset struct {
	Name string
	Data []byte
}

func LoadAssets(filenames []string) ([]Asset, error) {
	var assets []Asset
	for _, filename := range filenames {
		data, err := ioutil.ReadFile(filename)
		if err != nil {
			return nil, err
		}
		assets = append(assets, Asset{
			Name: filename,
			Data: data,
		})
	}
	return assets, nil
}

type Config struct {
	PackageName string
	Variable    string
}

func Generate(cfg *Config, assets []Asset) ([]byte, error) {
	buf := bytes.NewBuffer(nil)

	// Header.
	_, self, _, _ := runtime.Caller(0)
	fmt.Fprintf(buf, "// Code generated by %s. DO NOT EDIT.\n\n", filepath.Base(self))

	fmt.Fprintf(buf, "package %s\n\n", cfg.PackageName)

	// Variable.
	fmt.Fprintf(buf, "var %s = map[string][]byte{\n", cfg.Variable)
	for _, a := range assets {
		fmt.Fprintf(buf, "%q: []byte(%q),\n", a.Name, string(a.Data))
	}
	fmt.Fprint(buf, "}\n")

	return format.Source(buf.Bytes())
}
