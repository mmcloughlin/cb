// +build ignore

package main

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"runtime"
	"strings"

	"github.com/mmcloughlin/cb/app/brand"
)

func main() {
	if err := mainerr(); err != nil {
		log.Fatal(err)
	}
}

var (
	style     = flag.String("style", "", "path to css file to edit")
	numshades = flag.Int("shades", 9, "number of lighter shades")
)

const marker = "/* Palette"

func mainerr() error {
	flag.Parse()

	// Generate the palette.
	palette, err := Palette(*numshades)
	if err != nil {
		return err
	}

	// Read the style file.
	f, err := os.Open(*style)
	if err != nil {
		return err
	}

	out := bytes.NewBuffer(nil)
	s := bufio.NewScanner(f)
	output := true
	for s.Scan() {
		line := s.Text()
		switch {
		case !output && line == "}":
			out.Write(palette)
			output = true
		case strings.HasPrefix(line, marker):
			output = false
		case output:
			fmt.Fprintln(out, line)
		}
	}

	if err := f.Close(); err != nil {
		return err
	}

	// Write back.
	if err := ioutil.WriteFile(*style, out.Bytes(), 0644); err != nil {
		return err
	}

	return nil
}

func Palette(shades int) ([]byte, error) {
	buf := bytes.NewBuffer(nil)

	// Header.
	_, self, _, _ := runtime.Caller(0)
	fmt.Fprintf(buf, "%s generated by %s. DO NOT EDIT. */\n", marker, filepath.Base(self))

	fmt.Fprintf(buf, ":root {\n")
	for _, name := range brand.ColorNames {
		fmt.Fprintf(buf, "  --%s: %s;\n", name, strings.ToLower(brand.Colors[name]))
		for s := 1; s <= shades; s++ {
			shade, err := brand.Lighten(name, float64(s)/float64(shades+1))
			if err != nil {
				return nil, err
			}
			fmt.Fprintf(buf, "  --%s-%d: %s;\n", name, s, shade)
		}
	}
	fmt.Fprint(buf, "}\n")

	return buf.Bytes(), nil
}
