// +build ignore

package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"runtime"
	"strings"

	"github.com/iancoleman/strcase"
	"golang.org/x/tools/imports"
)

func main() {
	if err := mainerr(); err != nil {
		log.Fatal(err)
	}
}

var (
	input  = flag.String("input", "", "input model definitions")
	output = flag.String("output", "", "output go file")
)

func mainerr() error {
	flag.Parse()

	// Read.
	models, err := ReadModels(*input)
	if err != nil {
		return err
	}

	// Write source.
	buf := bytes.NewBuffer(nil)
	WriteModels(buf, models)

	// goimports
	src, err := imports.Process("", buf.Bytes(), nil)
	if err != nil {
		return err
	}

	// Output.
	var w io.Writer = os.Stdout
	if *output != "" {
		f, err := os.Create(*output)
		if err != nil {
			return err
		}
		defer f.Close()
		w = f
	}

	if _, err := w.Write(src); err != nil {
		return err
	}

	return nil
}

type Model struct {
	Name       string  `json:"name"`
	Doc        string  `json:"doc"`
	Collection string  `json:"collection"`
	ID         string  `json:"id"`
	Fields     []Field `json:"fields"`
}

func (m Model) Receiver() string {
	return strings.ToLower(m.Name[:1])
}

type Field struct {
	Name        string `json:"name"`
	DataType    string `json:"type"`
	KeyOverride string `json:"key"`
}

func (f Field) Type() string {
	if f.DataType == "" {
		return "string"
	}
	return f.DataType
}

func (f Field) Key() string {
	if f.KeyOverride == "" {
		return strcase.ToSnake(f.Name)
	}
	return f.KeyOverride
}

func ReadModels(filename string) ([]Model, error) {
	b, err := ioutil.ReadFile(filename)
	if err != nil {
		return nil, err
	}

	var models []Model
	if err := json.Unmarshal(b, &models); err != nil {
		return nil, err
	}

	return models, nil
}

func WriteModels(buf *bytes.Buffer, models []Model) {
	_, self, _, _ := runtime.Caller(0)
	fmt.Fprintf(buf, "// Code generated by %s. DO NOT EDIT.\n\n", filepath.Base(self))

	fmt.Fprint(buf, "package model\n\n")
	for _, model := range models {
		WriteModel(buf, model)
	}
}

func WriteModel(buf *bytes.Buffer, model Model) {
	// Struct definition.
	if model.Doc != "" {
		fmt.Fprintf(buf, "// %s\n", model.Doc)
	}
	fmt.Fprintf(buf, "type %s struct{\n", model.Name)
	for _, field := range model.Fields {
		fmt.Fprintf(buf, "%s %s `firestore:%q json:%q`\n", field.Name, field.Type(), field.Key(), field.Key())
	}
	fmt.Fprintf(buf, "}\n")

	// Type definition.
	fmt.Fprintf(buf, "// Type returns %q.\n", model.Collection)
	fmt.Fprintf(buf, "func (%s *%s) Type() string { return %q }\n", model.Receiver(), model.Name, model.Collection)

	// ID definition.
	fmt.Fprintf(buf, "// ID returns the %s field.\n", model.ID)
	fmt.Fprintf(buf, "func (%s *%s) ID() string { return %s.%s }\n", model.Receiver(), model.Name, model.Receiver(), model.ID)
}
