// Code generated by sqlc. DO NOT EDIT.
// source: commits.sql

package db

import (
	"context"
	"time"

	"github.com/lib/pq"
)

const buildCommitPositions = `-- name: BuildCommitPositions :exec
INSERT INTO commit_positions (
    SELECT
        c.sha,
        c.commit_time,
        (ROW_NUMBER() OVER (ORDER BY c.commit_time))-1 AS index
    FROM
        commits AS c
        INNER JOIN commit_refs AS r
            ON c.sha=r.sha AND r.ref = 'master'
)
ON CONFLICT (sha)
DO UPDATE SET index = EXCLUDED.index
`

func (q *Queries) BuildCommitPositions(ctx context.Context) error {
	_, err := q.exec(ctx, q.buildCommitPositionsStmt, buildCommitPositions)
	return err
}

const commit = `-- name: Commit :one
SELECT sha, tree, parents, author_name, author_email, author_time, committer_name, committer_email, commit_time, message FROM commits
WHERE sha = $1 LIMIT 1
`

func (q *Queries) Commit(ctx context.Context, sha []byte) (Commit, error) {
	row := q.queryRow(ctx, q.commitStmt, commit, sha)
	var i Commit
	err := row.Scan(
		&i.SHA,
		&i.Tree,
		&i.Parents,
		&i.AuthorName,
		&i.AuthorEmail,
		&i.AuthorTime,
		&i.CommitterName,
		&i.CommitterEmail,
		&i.CommitTime,
		&i.Message,
	)
	return i, err
}

const insertCommit = `-- name: InsertCommit :exec
INSERT INTO commits (
    sha,
    tree,
    parents,
    author_name,
    author_email,
    author_time,
    committer_name,
    committer_email,
    commit_time,
    message
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10
) ON CONFLICT DO NOTHING
`

type InsertCommitParams struct {
	SHA            []byte
	Tree           []byte
	Parents        pq.ByteaArray
	AuthorName     string
	AuthorEmail    string
	AuthorTime     time.Time
	CommitterName  string
	CommitterEmail string
	CommitTime     time.Time
	Message        string
}

func (q *Queries) InsertCommit(ctx context.Context, arg InsertCommitParams) error {
	_, err := q.exec(ctx, q.insertCommitStmt, insertCommit,
		arg.SHA,
		arg.Tree,
		arg.Parents,
		arg.AuthorName,
		arg.AuthorEmail,
		arg.AuthorTime,
		arg.CommitterName,
		arg.CommitterEmail,
		arg.CommitTime,
		arg.Message,
	)
	return err
}

const insertCommitPosition = `-- name: InsertCommitPosition :exec
INSERT INTO commit_positions (
    sha,
    commit_time,
    index
) VALUES (
    $1,
    $2,
    $3
) ON CONFLICT DO NOTHING
`

type InsertCommitPositionParams struct {
	SHA        []byte
	CommitTime time.Time
	Index      int32
}

func (q *Queries) InsertCommitPosition(ctx context.Context, arg InsertCommitPositionParams) error {
	_, err := q.exec(ctx, q.insertCommitPositionStmt, insertCommitPosition, arg.SHA, arg.CommitTime, arg.Index)
	return err
}

const insertCommitRef = `-- name: InsertCommitRef :exec
INSERT INTO commit_refs (
    sha,
    ref
) VALUES (
    $1,
    $2
) ON CONFLICT DO NOTHING
`

type InsertCommitRefParams struct {
	SHA []byte
	Ref string
}

func (q *Queries) InsertCommitRef(ctx context.Context, arg InsertCommitRefParams) error {
	_, err := q.exec(ctx, q.insertCommitRefStmt, insertCommitRef, arg.SHA, arg.Ref)
	return err
}

const mostRecentCommit = `-- name: MostRecentCommit :one
SELECT sha, tree, parents, author_name, author_email, author_time, committer_name, committer_email, commit_time, message FROM commits
ORDER BY commit_time DESC
LIMIT 1
`

func (q *Queries) MostRecentCommit(ctx context.Context) (Commit, error) {
	row := q.queryRow(ctx, q.mostRecentCommitStmt, mostRecentCommit)
	var i Commit
	err := row.Scan(
		&i.SHA,
		&i.Tree,
		&i.Parents,
		&i.AuthorName,
		&i.AuthorEmail,
		&i.AuthorTime,
		&i.CommitterName,
		&i.CommitterEmail,
		&i.CommitTime,
		&i.Message,
	)
	return i, err
}

const mostRecentCommitIndex = `-- name: MostRecentCommitIndex :one
SELECT
    MAX(index)::INT
FROM
    commit_positions
`

func (q *Queries) MostRecentCommitIndex(ctx context.Context) (int32, error) {
	row := q.queryRow(ctx, q.mostRecentCommitIndexStmt, mostRecentCommitIndex)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const mostRecentCommitWithRef = `-- name: MostRecentCommitWithRef :one
SELECT
    c.sha, c.tree, c.parents, c.author_name, c.author_email, c.author_time, c.committer_name, c.committer_email, c.commit_time, c.message
FROM
    commits AS c
    INNER JOIN commit_refs AS r
        ON c.sha=r.sha AND r.ref = $1
ORDER BY
    c.commit_time DESC
LIMIT 1
`

func (q *Queries) MostRecentCommitWithRef(ctx context.Context, ref string) (Commit, error) {
	row := q.queryRow(ctx, q.mostRecentCommitWithRefStmt, mostRecentCommitWithRef, ref)
	var i Commit
	err := row.Scan(
		&i.SHA,
		&i.Tree,
		&i.Parents,
		&i.AuthorName,
		&i.AuthorEmail,
		&i.AuthorTime,
		&i.CommitterName,
		&i.CommitterEmail,
		&i.CommitTime,
		&i.Message,
	)
	return i, err
}
