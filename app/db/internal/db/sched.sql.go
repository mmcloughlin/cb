// Code generated by sqlc. DO NOT EDIT.
// source: sched.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const commitModuleWorkerErrors = `-- name: CommitModuleWorkerErrors :many
SELECT
    target_uuid AS module_uuid,
    commit_sha,
    COUNT(*) FILTER (WHERE status = 'complete_error') AS num_errors,
    MAX(last_status_update)::TIMESTAMP WITH TIME ZONE AS last_attempt_time
FROM
    tasks
WHERE 1=1
    AND worker = $1
    AND type = 'module'
GROUP BY
    1, 2
HAVING 1=1
    AND COUNT(*) FILTER (WHERE status = 'complete_success') = 0
    AND COUNT(*) FILTER (WHERE status = 'complete_error') BETWEEN 1 AND $2::INT
    AND MAX(last_status_update) < $3
ORDER BY
    num_errors ASC,
    last_attempt_time ASC
LIMIT
    $4
`

type CommitModuleWorkerErrorsParams struct {
	Worker            string
	MaxErrors         int32
	LastAttemptBefore time.Time
	Num               int32
}

type CommitModuleWorkerErrorsRow struct {
	ModuleUUID      uuid.UUID
	CommitSHA       []byte
	NumErrors       int64
	LastAttemptTime time.Time
}

func (q *Queries) CommitModuleWorkerErrors(ctx context.Context, arg CommitModuleWorkerErrorsParams) ([]CommitModuleWorkerErrorsRow, error) {
	rows, err := q.query(ctx, q.commitModuleWorkerErrorsStmt, commitModuleWorkerErrors,
		arg.Worker,
		arg.MaxErrors,
		arg.LastAttemptBefore,
		arg.Num,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CommitModuleWorkerErrorsRow
	for rows.Next() {
		var i CommitModuleWorkerErrorsRow
		if err := rows.Scan(
			&i.ModuleUUID,
			&i.CommitSHA,
			&i.NumErrors,
			&i.LastAttemptTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recentCommitModulePairsWithoutWorkerTasks = `-- name: RecentCommitModulePairsWithoutWorkerTasks :many
SELECT
    p.sha AS commit_sha,
    p.commit_time,
    m.uuid AS module_uuid
FROM
    commit_positions AS p,
    modules AS m
WHERE NOT EXISTS (
        SELECT uuid, worker, commit_sha, type, target_uuid, status, last_status_update, datafile_uuid
        FROM tasks AS t
        WHERE 1=1
            AND t.commit_sha = p.sha
            AND t.type = 'module'
            AND t.target_uuid = m.uuid
            AND t.status = ANY ($1::task_status[])
            AND t.worker = $2
    )
ORDER BY
    p.commit_time DESC,
    m.uuid
LIMIT
    $3
`

type RecentCommitModulePairsWithoutWorkerTasksParams struct {
	Statuses []TaskStatus
	Worker   string
	Num      int32
}

type RecentCommitModulePairsWithoutWorkerTasksRow struct {
	CommitSHA  []byte
	CommitTime time.Time
	ModuleUUID uuid.UUID
}

func (q *Queries) RecentCommitModulePairsWithoutWorkerTasks(ctx context.Context, arg RecentCommitModulePairsWithoutWorkerTasksParams) ([]RecentCommitModulePairsWithoutWorkerTasksRow, error) {
	rows, err := q.query(ctx, q.recentCommitModulePairsWithoutWorkerTasksStmt, recentCommitModulePairsWithoutWorkerTasks, pq.Array(arg.Statuses), arg.Worker, arg.Num)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RecentCommitModulePairsWithoutWorkerTasksRow
	for rows.Next() {
		var i RecentCommitModulePairsWithoutWorkerTasksRow
		if err := rows.Scan(&i.CommitSHA, &i.CommitTime, &i.ModuleUUID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
