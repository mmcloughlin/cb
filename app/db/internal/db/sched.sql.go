// Code generated by sqlc. DO NOT EDIT.
// source: sched.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const recentCommitModulePairsWithoutWorkerResults = `-- name: RecentCommitModulePairsWithoutWorkerResults :many
SELECT
    c.sha AS commit_sha,
    m.uuid AS module_uuid
FROM
    commits AS c,
    modules AS m
WHERE 1=1
    AND c.commit_time > $1
    AND NOT EXISTS (
        SELECT r.uuid, r.datafile_uuid, line, benchmark_uuid, r.commit_sha, environment_uuid, metadata_uuid, iterations, value, b.uuid, package_uuid, full_name, b.name, unit, parameters, p.uuid, module_uuid, relative_path, f.uuid, f.name, sha256, t.uuid, worker, t.commit_sha, type, target_uuid, status, last_status_update, t.datafile_uuid
        FROM
            results AS r
            LEFT JOIN benchmarks AS b ON r.benchmark_uuid = b.uuid
            LEFT JOIN packages AS p ON b.package_uuid = p.uuid
            LEFT JOIN datafiles AS f ON r.datafile_uuid = f.uuid
            LEFT JOIN tasks AS t ON f.uuid = t.datafile_uuid
        WHERE 1=1
            AND r.commit_sha = c.sha
            AND p.module_uuid = m.uuid
            AND t.worker = $2
    )
ORDER BY
    c.commit_time DESC,
    m.uuid
LIMIT
    $3
`

type RecentCommitModulePairsWithoutWorkerResultsParams struct {
	Since  time.Time
	Worker string
	Num    int32
}

type RecentCommitModulePairsWithoutWorkerResultsRow struct {
	CommitSHA  []byte
	ModuleUUID uuid.UUID
}

func (q *Queries) RecentCommitModulePairsWithoutWorkerResults(ctx context.Context, arg RecentCommitModulePairsWithoutWorkerResultsParams) ([]RecentCommitModulePairsWithoutWorkerResultsRow, error) {
	rows, err := q.query(ctx, q.recentCommitModulePairsWithoutWorkerResultsStmt, recentCommitModulePairsWithoutWorkerResults, arg.Since, arg.Worker, arg.Num)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RecentCommitModulePairsWithoutWorkerResultsRow
	for rows.Next() {
		var i RecentCommitModulePairsWithoutWorkerResultsRow
		if err := rows.Scan(&i.CommitSHA, &i.ModuleUUID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
