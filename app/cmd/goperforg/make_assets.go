// +build ignore

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"runtime"
)

func main() {
	os.Exit(main1())
}

func main1() int {
	if err := mainerr(); err != nil {
		log.Print(err)
		return 1
	}
	return 0
}

// Command line flags.
var (
	output  = flag.String("output", "", "path to output file (default stdout)")
	pkg     = flag.String("pkg", "", "package name")
	varname = flag.String("var", "Assets", "variable name")
)

func mainerr() error {
	flag.Parse()

	filenames, err := ExpandPatterns(flag.Args())
	if err != nil {
		return err
	}

	assets, err := LoadAssets(filenames)
	if err != nil {
		return err
	}

	cfg := &Config{
		PackageName: *pkg,
		Variable:    *varname,
	}

	b, err := Generate(cfg, assets)
	if err != nil {
		return err
	}

	if *output != "" {
		err = ioutil.WriteFile(*output, b, 0644)
	} else {
		_, err = os.Stdout.Write(b)
	}

	return err
}

// ExpandPatterns expands glob patterns into a full list of files.
func ExpandPatterns(patterns []string) ([]string, error) {
	filenames := []string{}
	for _, pattern := range patterns {
		matches, err := filepath.Glob(pattern)
		if err != nil {
			return nil, err
		}
		filenames = append(filenames, matches...)
	}
	return filenames, nil
}

type Asset struct {
	Name string
	Data []byte
}

func LoadAssets(filenames []string) ([]Asset, error) {
	var assets []Asset
	for _, filename := range filenames {
		data, err := ioutil.ReadFile(filename)
		if err != nil {
			return nil, err
		}
		assets = append(assets, Asset{
			Name: filename,
			Data: data,
		})
	}
	return assets, nil
}

type Config struct {
	PackageName string
	Variable    string
}

func Generate(cfg *Config, assets []Asset) ([]byte, error) {
	buf := bytes.NewBuffer(nil)

	// Header.
	_, self, _, _ := runtime.Caller(0)
	fmt.Fprintf(buf, "// Code generated by %s. DO NOT EDIT.\n\n", filepath.Base(self))

	fmt.Fprintf(buf, "package %s\n\n", cfg.PackageName)

	// Variable.
	fmt.Fprintf(buf, "var %s = map[string][]byte{\n", cfg.Variable)
	for _, a := range assets {
		fmt.Fprintf(buf, "%q: []byte(%q),\n", a.Name, string(a.Data))
	}
	fmt.Fprint(buf, "}\n")

	return format.Source(buf.Bytes())
}
